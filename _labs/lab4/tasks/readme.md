# Руководство и задания к 4-ой практике. 

На практике поработаем с шаблонами и языком шаблонов. Потренируемся разделять и наследовать шаблоны.

###  Раздел 1. Знакомство с функцией render

Ранее мы создавали базу данных `DATABASE` в `models.py` приложения `app_store` и использовали её для получения JSON объекта
при подключении к пути http://127.0.0.1:8000/product , но у нас также есть путь 
http://127.0.0.1:8000/ который возвращает нашу стартовую страницу магазина, где участвуют наши товары.

Давайте используем нашу базу для того, чтобы заполнить данные в HTML файле `shop.html`, но
не вручную, а при помощи тегов шаблонизатора Django.

Для того чтобы Django указать, что необходимо использовать шаблонизатор для обработки HTML файла
существует функция `render` со своими входными параметрами.

Давайте изменим функцию представление `shop_view`, чтобы переписать его с использованием
`render`

```python
from django.shortcuts import render

def shop_view(request):
    if request.method == "GET":
        return render(request, 'shop.html')
```
![0.png](pic_for_task/0.png)

Зайдём по ссылке http://127.0.0.1:8000/ и получим ошибку, что шаблон не найден

![img.png](pic_for_task/img.png)

Данная ошибка вызвана тем, что Django будет искать данный html файл в папке `templates` во всех приложениях
описанных в словаре `INSTALLED_APPS` файла `settings.py`.

Поэтому в приложении `app_store` создадим папку `templates/app_store` и перенесём туда наш `shop.html`

![img_1.png](pic_for_task/img_1.png)

Теперь снова попробуем зайти на главную страницу (может так случиться, что ничего не изменилось, тогда 
остановите сервер сочетанием клавиш `Ctrl+C` в терминале. Заново запустите сервер и зайдите
на главную страницу)

При помощи функции `render` мы ушли от необходимости считывания файла и отправки `HttpResponse`, как делали ранее,
но теперь файлы html считываются только из отдельной папки `templates`.

У Django есть ещё одна особенность при работе с шаблонами. Ранее я говорил, что файл шаблонизатор ищет среди
тех приложений, которые указаны в словаре `INSTALLED_APPS` файла `settings.py`. Причём поиск идёт последовательно, сверху вниз.
Поэтому если в папках `templates` двух приложений будет одинаковый по названию файл, то
шаблонизатор выберет файл из того приложения, что ему попадётся первым из `INSTALLED_APPS`.

Проведём небольшой эксперимент. Создадим папку `templates` в приложении `app_datetime`.
В данной папке `templates` создадим пустой файл `shop.html`.

Перезагрузите сервер и посмотрите что будет если вы зайдёте на стартовую страницу. 
Теперь привычная картинка стала пустая. Как и было сказано ранее это произошло из-за специфики поиска
документов в Django.

![img_2.png](pic_for_task/img_2.png)

Существует подход активно используемый на практике, для обхода данных особенностей, этот подход заключается
в создании ещё одной папки с названием приложения в `templates` и переноса html файлов в данную папку, таким образом
даже если у двух приложений будут одинаковые названия файлов, то в `templates` они будут располагаться в своих
папках с приложениями и всё будет отображаться верно.

Вот как в итоге будет выглядеть путь `shop.html` в приложении `app_store`

![img_3.png](pic_for_task/img_3.png)

Но, мы сменили путь к `shop.html`, а значит должны указать правильный маршрут в функции `render` нашего представления
`shop_view`

```python
def shop_view(request):
    if request.method == "GET":
        return render(request, 'app_store/shop.html')
```

Заходим на главную страницу http://127.0.0.1:8000/ и видим, что всё снова отображается верно.

###  Раздел 2. Знакомство с тегом static

Представим такую ситуацию - нам срочно нужно переехать на новый сервер, но все 
статические файлы (картинки, скрипты javascript, css файлы) мы хотим перенести на отдельный сервер, чтобы
в случае чего данные проще было использовать, если что-то выйдет из строя. Но вот незадача, 
чтобы это сделать во всех наших html файлах нужно будет вручную поменять все ссылки на новый сервер, иначе
картинки на сайте просто не откроются.

Для того чтобы минимизировать ручные изменения ссылок в будущем, мы в текущем состоянии используем тег `static` который
считает шаблонизатор Django и при формировании html станицы в виде ответа - Django самостоятельно подставит нужный
начальный путь, где лежат картинки.

Но у данного подхода аналогичные особенности, как и у поиска html файлов:

1. Должна быть специальная папка `static` в приложении
2. Если вдруг в двух разных приложениях в папке `static` будут одинаковые файлы, то как и в случае с `templates`
файл загрузится из того приложения что будет выше в `INSTALLED_APPS`. Поэтому тут как и с `templates` продублируем
название приложения в виде папки в `static`

В итоге наше приложение `app_store` теперь выглядит так:

![img_4.png](pic_for_task/img_4.png)

#### 2.1 Переписывание ссылок с использованием тега static

Поправим наш html файл `shop.html` приложение `app_store` так как путь до статических файлов изменился.

Используем для этого тег `{% static %}`

Для начала загрузим эту возможность в наш html файл, для этого вверху файла пропишем `{%load static%}`

![img_5.png](pic_for_task/img_5.png)

Затем все ссылки на статические файлы необходимо заменить с использованием тега `static`

Например ссылка (14 строка `shop.html`):

```html
href="static/css/open-iconic-bootstrap.min.css"
```
Трансформируется в (не забываем, что теперь наши статические файлы находятся в дополнительной папке `app_store`)

```html
href="{% static 'app_store/css/open-iconic-bootstrap.min.css' %}"
```

А данная ссылка на 74 строке `shop.html`

```html
style="background-image: url(static/images/bg_1.jpg);"
```
Трансформируется в 

```html
style="background-image: url({% static 'app_store/images/bg_1.jpg' %});"
```

И так необходимо сделать со всеми статическими файлами(картинки, css, js) в `shop.html`

#### 2.2 Групповая замена ссылок

Для облегчения работы можно воспользоваться поиском с заменой в файле. В файле 
`shop.html` нажмите комбинацию клавиш `Ctrl+R`, где появятся 2 поля:

* верхнее поле ищет текст, что написан;
* нижнее поле заменяет на текст, что написан;

Найдем `static/` и заменим на `{% static 'app_store/` (настоятельно рекомендую нажать Replace и
пройтись по каждой предложенной строчке, чтобы увидеть где-же в данном html находятся статические файлы)

![img_6.png](pic_for_task/img_6.png)

Но одного открытого тега `{%` мало, нужно его закрыть, но сложность заключается в том, что у статических файлов 
много расширений, поэтому будем работать с каждым отдельно.

| Ищем   | Заменяем на |
|--------|-------------|
| `css"` | `css' %}"`  |
| `jpg"` | `jpg' %}"`  |
| `png"` | `png' %}"`  |
| `js"`  | `js' %}"`   |

Перезагрузите сервер и проверьте всё ли корректно работает

Если всё выполнено верно, то главная страница должна корректно отображаться.

Также корректность загрузки всех статических элементов можно проверить в терминале сервера. Все файлы
будут с кодом 200, а не кодом 404.

![img_7.png](pic_for_task/img_7.png)

###  Раздел 3. Работа с параметрами передаваемыми в шаблон

Далее отправим характеристики товаров в файл `shop.html` (для того, чтобы иметь возможность
при изменении товаров в `DATABASE` - товары автоматически менялись в магазине)

Для этого через параметр `context` функции `render` можно передать словарь, значения которого
будут использоваться для подстановки значений в html файл.

В нашем случае в функцию `render` представления `shop_view` пропишем следующее

```python
return render(request, 
              'app_store/shop.html', 
              context={"products": DATABASE.values()})
```

В `context` передаём словарь с ключом `products` и всеми продуктами, что есть в базе данных

#### 3.1 Работа с тегом {% for %}

В `shop.html` на 99 строке найдём блок

```html
<div class="col-md-6 col-lg-3 ftco-animate">
```

Их всего 12 штук, ровно столько сколько есть товаров. В данном блоке содержится информация
о товаре.

До открытия этого блока поставьте тег открытия цикла 

```
{% for product in products %}
```

а после закрытия блока продукта поставьте тег закрытия цикла

```
{% endfor %}
```

Или можете свернуть блок 

![img_8.png](pic_for_task/img_8.png)

и до и после блока поставить теги

![img_9.png](pic_for_task/img_9.png)

Конструкция `for product in products` выглядит довольно знакомо для Python, но
что такое `products`? `products` это равно тот ключ, что мы передавали в `context`.
Вот что передавали 
```python
context={"products": DATABASE.values()}
``` 

соответственно в `products` у нас итерируемый объект со всеми продуктами.

Если зайти на главную страницу, то увидим множество клонов Болгарского перца, ровно 12
штук, именно столько товаров в `DATABASE.values()`.

Но хотелось бы иметь те товары, что есть в базе данных, а не 12 клонов одного товара.

Теперь мы подошли к понятию использования переменных шаблона. В шаблонизаторе обращение 
к объекту переменной идёт через `.`, когда в python по `[]`, поэтому, для обращения будем 
использовать:

| Описание          | Значение         | На что заменить            |
|-------------------|------------------|----------------------------|
| Скидка            | 30               | `{{product.discount}}`     |
| Название продукта | Болгарский перец | `{{product.name}}`         |
| Регулярная цена   | 300              | `{{product.price_before}}` |
| Цена со скидкой   | 210              | `{{product.price_after}}`  |

![img_10.png](pic_for_task/img_10.png)

Если обратиться к главной странице, то увидим, что теперь описания и цены поменялись,
но неправильное отображение картинки товара и скидки

![img_11.png](pic_for_task/img_11.png)

Поправим сначала картинку.

В данном примере работа с картинкой выбивается от общего паттерна, так как данная картинка уже в теге
`{%static%}`

![img_12.png](pic_for_task/img_12.png)

а раз картинка в теге, то можно передать её значение без дополнительных скобок(если значение не в теге, 
то передаём как делали ранее через `{{}}`)

| Описание              | Значение                       | На что заменить        |
|-----------------------|--------------------------------|------------------------|
| Расположение картинки | app_store/images/product-1.jpg | `product.url`          |

![img_13.png](pic_for_task/img_13.png)

Вопрос с одинаковыми картинками решен, но со скидкой вопрос остался

![img_14.png](pic_for_task/img_14.png)

#### 3.2 Работа с условиям - тег {% if %}


Чтобы решить вопрос со скидкой нужно понять как поставить условие, так как если 
`{{product.discount}}` не None, то скидка есть, иначе отображается только одна цена, 
зеленая плашка слева вверху картинки не отображается. У языка шаблонов есть для этого
блок тегов `{%if%}...{%else%}...{%endif%}`, который мы и используем.

Решим вопрос с зеленой плашкой и поставим блок тегов как на картинке(нового html кода нет, только размещены теги).

После 103 строки.

```python
{% if product.discount %}
<span class="status">{{product.discount}}%</span>
{% else %}
<div class="overlay"></div>
{% endif %}
```


![img_15.png](pic_for_task/img_15.png)

А с зачеркивающимися ценами поступим так, если скидка есть, то оставляем что есть, а если скидки нет,
то просто пишем регулярную цену после 114 строки

```html
{% if product.discount %}
<span class="mr-2 price-dc">&#x20bd {{product.price_before}}</span>
<span class="price-sale">&#x20bd {{product.price_after}}</span>
{% else %}
<span>&#x20bd {{product.price_before}}</span>
{% endif %}
```

![img_16.png](pic_for_task/img_16.png)

Теперь всё отображается корректно, но товаров больше чем нужно, так как остальные 11
товаров после цикла отображаются дублируя информацию. Удалим их. Для этого можете свернуть все блоки 
```html
<div class="col-md-6 col-lg-3 ftco-animate">
```
А затем удалить блоки после закрытого тега цикла.

![img_17.png](pic_for_task/img_17.png)

После удаления

![img_18.png](pic_for_task/img_18.png)

В итоге после удаление лишнего главная страница вернётся к правильному отображению. 
При этом мы храним меньше html кода.

#### 3.3 Работа с тегом {% url %}

Но вот незадача, при переходе по картинке товара, мы всё время переходим на Болгарский перец, вместо нужного товара 
(не обращаем внимания, если нет картинок при переходе на товар,
это вызвано с изменением папки со статическими файлами, чтобы были ранее).

Данный переход связан с тем, что в цикле ссылаемся на постоянное значение ссылки

![img_19.png](pic_for_task/img_19.png)

Для решения данной проблемы можно пойти несколькими путями: 

1. Ручное прописывание пути с параметром.

```html
"product/{{product.html}}.html"
```

В базе данных в ключе `html` лежит нужное значение

![img_20.png](pic_for_task/img_20.png)

Данный подход череват тем, что если вы решите изменить маршрут по которому будет обрабатываться
информация о продукте, то придётся в html вручную исправлять ссылку.

2. Использование тега `{% url %}` возвращающего маршрут обработчика по имени обработчика

```html
href="{% url 'product_page_view' product.html %}"
```

![img_21.png](pic_for_task/img_21.png)

Но в таком подходе придётся именовать обработчики, чтобы их затем можно было использовать для получения пути.

Для это в `urls.py` приложения `app_store` пропишем имя обработчика маршрутов через параметр `name`

![img_22.png](pic_for_task/img_22.png)

Имя обработчику можно дать любое, главное чтобы было понятное.

Данный подход уже не завязан на ручном изменении, и изменение маршрута до обработчика 
не повлияет на результат перехода.

Однако существует вероятность, что вы назовете обработчики одинаково в двух разных приложениях (вспомните особенности папки 
static и templates), поэтому в данном случае можно разделить пространства имён обработчиков приложений.

Для этого в `urls.py` приложения `app_store` создадим переменную `app_name` и присвоим ей значение `'app_store'`

![img_23.png](pic_for_task/img_23.png)

А уже в `shop.html` в теге `{{% url %}}` пропишем пространство приложения 
`{% url 'app_store:products_page_view' product.html %}`

![img_24.png](pic_for_task/img_24.png)

Таким образом вы можете назвать обработчики одинаково в двух приложениях и быть уверенными, 
что они будут обрабатывать верно.

Общая концепция следующая:

> из переменной `app_name` в `urls.py` приложения подставляется в путь слева от `:`,
а из переменной `name` (строки маршрута) в `urls.py` приложения подставляется в путь справа от `:` тега `{% url 'app_name:name' %}` в
html файле.

![img_24_1.png](pic_for_task/img_24_1.png)

###  Раздел 4. Работа с HTML представлением корзины

#### 4.1 Подключение html и настройка отображения

Ранее мы работали с корзиной покупок через JSON, теперь же давайте подключим html файл для более наглядного отображения
данных.

Из папки `_labs/lab4/files` скопируйте `cart.html` в `app_store/templates/app_store`

В данном `html` файле уже прописаны статические файлы, так что осталось только прописать представление.

Напишем представление `cart_view` приложения `app_store`.

```python
def cart_view(request):
    if request.method == "GET":
        return render(request, "app_store/cart.html")
```

Добавим обработчик маршрута на `cart_view` по адресу `cart/` в `urls.py` приложения `app_store`

Теперь при переходе на http://127.0.0.1:8000/cart/ получим представление корзины.

Но текущая возвращаемая корзина, не совпадает с той, что получаем в формате JSON по адресу http://127.0.0.1:8000/cart/json/. 
Давайте это поправим. В `cart_view` допишем список продуктов которые есть в корзине. 

Вообще, у нас уже есть словарь с продуктами и их количеством в корзине в файле `cart.json`. 
Но это всего лишь ссылки на `id` продукта, без характеристик продукта,
а характеристики нам нужны для полноценного отображения в html файле корзины. 

> Почему мы храним в `cart.json` только id и их количество? Так было сделано, так как это типичная ситуация для хранения 
информация о корзине в `cookie` файле.
> 
> Ку́ки (англ. cookie) — небольшой набор данных, отправляемый веб-сервером и хранимый на компьютере 
пользователя без изменений и какой-либо обработки. Веб-клиент (обычно веб-браузер) всякий раз при обращении к соответствующему 
сайту пересылает эти данные веб-серверу в составе HTTP-запроса. Обычно куки применяют для:
> * аутентификации пользователя; 
> * хранения персональных предпочтений и настроек пользователя; 
> * отслеживания состояния сеанса доступа пользователя; 
> * хранения сведений статистики о пользователе.


Создадим словарь для хранения характеристик продукта, а затем эти данные передадим в шаблон `cart.html` для заполнения через `render`

В `cart_view` допишите код, формирующий данные о характеристиках продукта, которые затем пойдут в `render`

```python
def cart_view(request):
    if request.method == "GET":
        username = ''
        data = view_in_cart(username)[username]  # Получаем корзину пользователя username

        products = []  # Список продуктов
        for product_id, quantity in data['products'].items():
            product = DATABASE[product_id]  # Получаем информацию о продукте 
            # TODO в словарь product под ключом "quantity" запишите текущее значение количества товара в корзине
            product["quantity"] = ...  # Реализуйте
            # TODO в словарь product под ключом "price_total" посчитайте и запишите общую стоимость товара как произведение 
            #  его количества в корзине на цену с учетом скидки ('price_after'). Значение цены "price_total" приведите к формату 
            #  2 символов после запятой
            product["price_total"] = ...  # Реализуйте
            # TODO добавьте словарь product в конец списка products
            # Реализуйте

        return render(request, "app_store/cart.html", context={"products": products})
```

#### 4.2 Корректировка правильного отображения данных из cart.json в html

Осталось только подправить `cart.html`, чтобы те товары, что мы передавали в словаре через `context` в `render` 
теперь встали в правильное место в `cart.html`.

Найдем тег `<tbody>` он описывает что будет показываться в html таблице.

Внутри `<tbody>` будет объект `tr` он выглядит так `<tr class="text-center">` их будет 2 штуки, 
это и есть блоки с отображаемой информацией о товаре.

По примеру прошлого раза, когда работали с `shop.html` оборачиваем нашу строку с продуктами в цикл 

```html
{% for product in products %}
...
{% endfor %}
```

![img_28.png](pic_for_task/img_28.png)

И заменяем следующие переменные

| Описание              | Значение                         | На что заменить              |
|-----------------------|----------------------------------|------------------------------|
| Расположение картинки | 'app_store/images/product-1.jpg' | `product.url`                |
| Название продукта     | Болгарский перец                 | `{{product.name}}`           |
| Описание              | Сочный и яркий, он ...           | `{{product.description}}`    |
| Цена после скидки     | 210                              | `{{product.price_after}}`    |
| Количество товара     | value="1"                        | `value={{product.quantity}}` |
| Общая цена позиции    | 210                              | `{{product.price_total}}`    |


В итоге код строки товара будет в следующем виде

![img_29.png](pic_for_task/img_29.png)

После того, как доделали формирование товара через цикл, то удаляем все лишние блоки `<tr class="text-center">` (он будет 
всего один сразу после `{% endfor %}`)

И если всё сделано верно, то в корзине будут товары с базы `cart.json`. Проверьте, что действительно отображается то, что есть в 
`cart.json` http://127.0.0.1:8000/cart/json/

Добавьте пару товаров как делали ранее

http://127.0.0.1:8000/cart/add/10, посмотрите что изменится в корзине.

Попробуйте удалить пару товаров из корзины.

http://127.0.0.1:8000/cart/del/10

Так как в `cart.html` уже есть javascript код, то при изменении количества товара прямо на странице - пересчитывает общая 
цена всей корзины на стороне клиента без перезагрузки страницы.


![img_29_1.png](pic_for_task/img_29_1.png)


###  Раздел 5. Создание и использование общих шаблонов для файлов

#### 5.1 Анализ похожести файлов

Если посмотреть на html файлы с которыми мы работали `cart.html`, `shop.html`, да и любой html из папки product, то есть определенные
блоки повторяющиеся в каждом файле.

Допустим можно посмотреть где же есть различие между файлами. Для этого выделите два сравниваемых файла в нашем случае `cart.html` и `shop.html`
и нажмите правую кнопку мыши на них и выберите `Compare Files`

![img_30.png](pic_for_task/img_30.png)

Появится окно в котором можно посмотреть, где существенные различия между файлами (синий цвет)

Основные различия идут после комментария `<!-- END nav -->`, когда заканчивается навигационный блок.

![img_31.png](pic_for_task/img_31.png)

А начиная с секции `<section class="ftco-section ftco-no-pt ftco-no-pb py-5 bg-light">` снова всё повторяется

![img_32.png](pic_for_task/img_32.png)

Исключение составляет блок с javascript, у `cart.html` есть дополнительные скрипты

![img_33.png](pic_for_task/img_33.png)

#### 5.2 Создание общего файла для расширения

В папке `app_store/templates/app_store` создадим шаблон `base.html` в нём будет заполненная структура шаблона (то, что чаще всего
повторяется в наших html файлах)

Заполните `base.html` данным кодом

```html
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    {% block title %} <!-- Блок для названия страницы-->
    
    {% endblock %}
    
    {% block head %} <!-- Блок ссылок в head-->

    {% endblock %}
</head>
<body class="goto-here">
    {% block header %} <!-- Блок для header страницы с данными магазина-->

    {% endblock %}
    
    {% block nav %} <!-- Блок для навигационной панели страницы магазина-->

    {% endblock %}
    
    {% block content %} <!-- Блок для уникального содержимого страницы-->
    
    {% endblock %}
    
    {% block news %} <!-- Блок для новостной панели-->

    {% endblock %}
    
    {% block footer %} <!-- Блок для нижней панели страницы-->

    {% endblock %}
    
    {% block scripts %} <!-- Блок для загрузки javascript страницы-->

    {% endblock %}
    
    {% block custom_scripts %}  <!-- Блок для загрузки дополнительного кода встроенного в html-->

    {% endblock %}
</body>
</html>
```

Далее из `shop.html` в `base.html` скопируем содержимое определенных блоков (то, что будет повторяться в разных html файлах)

1. В `base.html` в блок
```html
{% block title %} 
... 
{% endblock %}
```
из `shop.html` скопируйте всё в теге `<head></head>` кроме `<title>Интернет-магазин здоровых продуктов</title>`

![img_34.png](pic_for_task/img_34.png)

2. В `base.html` в блок
```html
{% block header %} 
... 
{% endblock %} 
```
из `shop.html` скопируйте блок `<div class="py-1 bg-primary">` с его содержимым (блок проще копировать в свернутом виде)

![img_34_1.png](pic_for_task/img_34_1.png)


3. В `base.html` в блок
```html
{% block nav %} 
... 
{% endblock %}
```
из `shop.html` скопируйте блок 
`<nav class="navbar navbar-expand-lg navbar-dark ftco_navbar bg-dark ftco-navbar-light" id="ftco-navbar">` с его содержимым (блок проще копировать в свернутом виде)

![img_34_2.png](pic_for_task/img_34_2.png)


4. В `base.html` в блок
```html
{% block news %} 
... 
{% endblock %}
```
из `shop.html` скопируйте блок `<section class="ftco-section ftco-no-pt ftco-no-pb py-5 bg-light">` с его содержимым

![img_34_3.png](pic_for_task/img_34_3.png)

5. В `base.html` в блок
```html
{% block footer %} 
... 
{% endblock %}
```
из `shop.html` скопируйте блок `<footer class="ftco-footer ftco-section">` с его содержимым

![img_34_4.png](pic_for_task/img_34_4.png)

6. В `base.html` в блок
```html
{% block scripts %} 
... 
{% endblock %}
```
из `shop.html` скопируйте содержимое от `<!-- loader -->` до закрывающегося тега `</body>` 
исключая блок `<!-- Блок дополнительных пользовательских скриптов-->`

![img_34_5.png](pic_for_task/img_34_5.png)

В итоге блок `<body></body>` в `base.html` будет выглядеть так

![img_35.png](pic_for_task/img_35.png)

#### 5.3 Работа с тегом extends

Теперь подготовим файл `shop.html`. 

В `shop.html` наверху пропишите тег для расширения файла шаблоном

```html
{% extends 'app_store/base.html' %}
```

Затем в `shop.html` оставите только следующие блоки с содержимым (остальное удалите)

* `<title>Интернет-магазин здоровых продуктов</title>`
* `<div class="hero-wrap hero-bread" style="background-image: url({% static 'store/images/bg_1.jpg' %});">`
* `<section class="ftco-section">`

Будет выглядеть следующим образом

![img_36.png](pic_for_task/img_36.png)

Затем обернем всё в нужные теги (то, что будет использоваться в данном файле, но не будет в другом)

```html
{% block title %} 
... 
{% endblock %}

{% block content %} 
... 
{% endblock %}

{% block custom_scripts %}
...
{% endblock %}
```

![img_37.png](pic_for_task/img_37.png)

Теперь при обработке запроса на получение страницы `shop.html`, Django скопирует все из `base.html` в `shop.html`, а там где были переопределены блоки `{% block title %}` 
и `{% block content %}` теперь будут стоять данные, что добавили в `shop.html`.

Если всё было перенесено верно, то теперь при открытии http://127.0.0.1:8000/ у вас верно отобразиться главная страница,
а значит расширение шаблона прошло успешно.

#### 5.4 Самостоятельно проведите расширение страницы cart.html

Аналогично как с `shop.html` проведите расширение шаблоном `base.html` для `cart.html`. 

В `base.html` ничего менять не нужно, 
а в `cart.html` необходимо удалить лишнее (что повторяется во всех файлах, теже блоки, что были удалены в `shop.html`). 

А теги `{% block title %}` и `{% block content %}` заполнить нужными данными. 

* `<title>Корзина</title>`
* `<div class="hero-wrap hero-bread" style="background-image: url({% static 'app_store/images/bg_1.jpg' %});">`
* `<section class="ftco-section ftco-cart">`

Однако в `cart.html` есть еще 4 отдельных javascript, которые будут в
блоке `{% block custom_scripts %}`

В итоге должно выглядеть примерно так

![img_38.png](pic_for_task/img_38.png)

И если всё выполнено верно, то по http://127.0.0.1:8000/cart/ будет всё отображаться верно и все javascript будут 
работать верно.

###  Раздел 6. Применение фильтрации на главной странице

Это будет заключительный раздел на данной практике

#### 6.1 Отображение информации о продукте с использованием шаблона и вывод товаров той же категории

Ранее мы копировали папку `product` с html файлами продуктов, теперь мы знаем как создавать шаблоны и подключать теги
поэтому просто скопируйте `product.html` из `_labs/lab4/files` в `app_store/templates/app_store` там уже все подключено,
нужно только использовать `render` в представлении `product_page_view` для отображения продукта, и передать параметры для подстановки в шаблон

Замените код представления `product_page_view` во `views.py` приложения `app_store` на следующий код

```python
def product_page_view(request, page):
    if request.method == "GET":
        if isinstance(page, str):
            for data in DATABASE.values():
                if data['html'] == page:  # Если значение переданного параметра совпадает именем html файла
                    data_other_products = DATABASE.values()  # TODO Переделать по заданию
                    return render(request, 'app_store/product.html', context={'product': data,
                                                                              'other_products': data_other_products})

        elif isinstance(page, int):
            data = DATABASE.get(str(page))  # Получаем какой странице соответствует данный id
            if data:  # Если по данному page было найдено значение
                data_other_products = DATABASE.values()  # TODO Переделать по заданию
                return render(request, 'app_store/product.html', context={'product': data,
                                                                          'other_products': data_other_products})

        return HttpResponse(status=404)
```

Перейдите на любой продукт из главной страницы, теперь render будут корректно всё отрабатывать, а не будет считывание 
html файла с папки. Если дойти до конца страницы с продуктом, то появится блок товары той же категории, однако там будут все товары,
так как в переменной `data_other_products` записываются все товары. Ваша задача в `data_other_products` записать 5 товаров
той же категории, что и искомый товар, однако искомый товар должен быть исключен из этого вывода. Например, у нас есть "Болгарский перец",
у него категория "Овощи", соответственно в `data_other_products` нужно записать 5 любых товаров категории "Овощи", но в
`data_other_products` не должно быть товара "Болгарский перец".

![img_43.png](pic_for_task/img_43.png)

#### 6.2 Применение фильтрации на главной странице

Ранее мы с вами делали функции способные фильтровать наши товары, вы даже сделали
представление возвращающее JSON с фильтрующими параметрами.

Теперь давайте применим это.

Скопируем код, что был ранее для фильтрации из параметров запроса представления
`products_view` и используем это для фильтрации товаров на главной странице.

Ниже приведен полный код `shop_view` с возможностью фильтрации

```python
def shop_view(request):
    if request.method == "GET":
        # Обработка фильтрации из параметров запроса
        category_key = request.GET.get("category")
        if ordering_key := request.GET.get("ordering"):
            if request.GET.get("reverse") in ('true', 'True'):
                data = filtering_category(DATABASE, category_key, ordering_key, True)
            else:
                data = filtering_category(DATABASE, category_key, ordering_key)
        else:
            data = filtering_category(DATABASE, category_key)
        return render(request, 'app_store/shop.html',
                      context={"products": data})
```

Теперь через адресную строку можно фильтровать, так как в `products` отправляем именно те продукты, что ходим
после фильтрации.

Перейдите по адресам и посмотрите на результат

* http://127.0.0.1:8000/
* http://127.0.0.1:8000/?category=Овощи
* http://127.0.0.1:8000/?category=Фрукты
* http://127.0.0.1:8000/?category=Соки
* http://127.0.0.1:8000/?category=Семена


#### 6.3 Применение фильтрации на главной странице при нажатии на кнопку

Сделаем фильтрацию по нажатию ссылку категории, так как писать в адресной строке очень неудобно 

![img_25.png](pic_for_task/img_25.png)

Для этого в `urls.py` приложения `app_store` назовем обработчик

```python
path('', shop_view, name="shop_view")
```
![img_26.png](pic_for_task/img_26.png)

Затем в представлении `shop_view` в словарь передадим какую категорию выбрали для фильтрации в словарь `context`

```python
context={"products": data,
         "category": category_key})
```

![img_27.png](pic_for_task/img_27.png)

И наконец в `shop.html` найдём `<ul class="product-category">`

И приведенные элементы списка 

```html
<li><a href="#" class="active">Все</a></li>
<li><a href="#">Овощи</a></li>
<li><a href="#">Фрукты</a></li>
<li><a href="#">Соки</a></li>
<li><a href="#">Семена</a></li>
```

Замените их на 

```html
{% if category is None %}
<li><a href="{% url 'app_store:shop_view' %}" class="active">Все</a></li>
{% else %}
<li><a href="{% url 'app_store:shop_view' %}">Все</a></li>
{% endif %}

{% if category == 'Овощи' %}
<li><a href="{% url 'app_store:shop_view' %}?category={{category}}" class="active">Овощи</a></li>
{% else %}
<li><a href="{% url 'app_store:shop_view' %}?category=Овощи">Овощи</a></li>
{% endif %}

{% if category == 'Фрукты' %}
<li><a href="{% url 'app_store:shop_view' %}?category={{category}}" class="active">Фрукты</a></li>
{% else %}
<li><a href="{% url 'app_store:shop_view' %}?category=Фрукты">Фрукты</a></li>
{% endif %}

{% if category == 'Соки' %}
<li><a href="{% url 'app_store:shop_view' %}?category={{category}}" class="active">Соки</a></li>
{% else %}
<li><a href="{% url 'app_store:shop_view' %}?category=Соки">Соки</a></li>
{% endif %}

{% if category == 'Семена' %}
<li><a href="{% url 'app_store:shop_view' %}?category={{category}}" class="active">Семена</a></li>
{% else %}
<li><a href="{% url 'app_store:shop_view' %}?category=Семена">Семена</a></li>
{% endif %}
```

![img_27_1.png](pic_for_task/img_27_1.png)


В приведенном коде проверяется какая категория есть в параметрах переданных в шаблон, и затем
эту категорию делаем активной (появляется зелёная обводка).

Теперь при нажатии на кнопку категории на главной странице происходит фильтрация. 

#### 6.4 Облегчение перехода по ссылкам на главной странице

Ранее мы с вами постоянно обращались к адресной строке, чтобы перейти на тот или иной функционал. Но это неудобно когда
переходим часто. Пропишем в нашей навигационной панели переходы, чтобы можно было перемещаться через навигационную панель.

Для этого в `base.html` внутри блока `<ul class="navbar-nav ml-auto">`, где лежат ссылки для перехода по странице
пропишем ссылки для переходов, воспользуемся тегом `{% url %}`

* `href="{% url 'app_store:shop_view' %}"`
* `href="{% url 'app_store:cart_view' %}"`

Названия обработчиков возьмём из `urls.py` приложения `app_store`, не забудем прописать название маршрута для `cart_view`. 

![img_27_2.png](pic_for_task/img_27_2.png)

Теперь во всех html файлах, где используется `base.html` в шапках появились актуальные ссылки для перехода по нажатию на 
"Магазин" и "Корзина".

# Практика окончена

Зафиксируем изменения сделав коммит и отправим эти коммиты на github
